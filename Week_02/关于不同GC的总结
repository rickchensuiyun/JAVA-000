

1.串行GC
    特点：单线程工作，GC时会暂停所有的业务线程直到GC结束。使用标记--复制算法处理年轻代，标记--整理算法处理老年代。

2.并行GC
    这是串行GC的多线程版本，和串行GC一样，GC时同样会暂停所有的工作线程，回收策略和算法也和串行GC一致。在多核环境下，并行GC
    相比串行GC有着更高的效率。
    从gc.serial.log和gc.parallel.log相比也能看出来并行的GC延迟会稍微低一些。

3.CMS
    特点：面向老年代，以缩短回收停顿时间为目标，几乎不会暂停业务线程，是一个可以并发的GC。
    采用的是标记--清除算法，由于没有整理压缩内存，所以采用空闲列表的方式来记录空闲内存，这样导致吞吐量相比标记--整理算法实现的GC的吞吐量要低。
    不过大部分B/S架构的应用更关注的暂停响应时间，而不是吞吐量，所以CMS更好。

4.G1
    特点：新一代，面向全堆的GC，表现更好。基于Region的内存布局，面向局部收集，采用标记--整理算法。

    收集效率高：由于G1是基于Region划分的，直接把java堆划分为多个大小相等的region，而不是像其他旧的GC一样，固定大小，固定分代，这样就可以根据每个region的回收效益，优先回收收益最大的region，从而保证在有限的时间内获得更高的收集效率。

    相比CMS，G1并不追求纯粹的低延迟，通过设置MaxGCPauseMillis参数来获取延迟和高吞吐量中的一个平衡。
    缺点：G1的内存占用和执行的负载比CMS要高，要在较大内存的环境中才能发挥其优势。
